# 1.设计模式概述

- 创建型模式（5种）工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式（7种）适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式
- 行为型模式（11种）策略模式、模板方法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭代器模式、命令模式、状态模式、备忘录模式、解释器模式

## 23种设计模式

### 创建型模式（5种）

1. **单例模式**: 保证一个类只有一个实例，并提供一个全局访问点。
2. **工厂模式**: 定义一个用于创建对象的接口，由子类决定实例化类型。
3. **抽象工厂模式**: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。
4. **建造者模式**: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
5. **原型模式**: 用于创建复杂对象的成本过大时，通过复制已有对象的方式来创建新对象。

### 结构型模式（7种）

1. **适配器模式**: 将一个类的接口转换成客户希望的另一个接口，使得原本不兼容的类可以一起工作。
2. **桥接模式**: 将抽象与其实现分离，使得它们可以独立变化，提高系统的灵活性。
3. **组合模式**: 将对象组合成树形结构以表示"整体-部分"的层次结构，使得客户对单个对象和复合对象的使用具有一致性。
4. **装饰者模式**: 动态地给一个对象添加一些额外的职责，同时又不改变其结构。
5. **外观模式**: 提供了一个统一的接口，用于访问子系统的一群接口，简化了客户端与子系统之间的交互。
6. **享元模式**: 通过共享技术来有效地支持大量细粒度的对象，节省了内存和CPU的开销。
7. **代理模式**: 为其他对象提供一个代理，以控制对这个对象的访问。

### 行为型模式（11种）

1. **模板方法模式**: 定义一个操作中的算法骨架，将一些步骤延迟到子类中实现。
2. **策略模式**: 定义一系列算法，将每个算法封装起来，并使它们可以相互替换，让算法独立于使用它的客户而变化。
3. **命令模式**: 将请求封装成对象，使得可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
4. **责任链模式**: 通过避免将请求发送者与接收者耦合在一起来实现解耦，使多个对象都有机会处理请求。
5. **中介者模式**: 用一个中介对象来封装一系列对象之间的交互，使各对象不需要显式地相互引用，从而使其松散耦合。
6. **观察者模式**: 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象的状态发生变化时，会通知所有观察者。
7. **迭代器模式**: 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
8. **备忘录模式**: 在不破坏封装性的前提下，保存一个对象的某个状态，以便在适当的时候恢复对象。
9. **解释器模式**: 给定一个语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
10. **访问者模式**：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新操作。
11. **状态模式**: 允许对象在其内部状态改变时改变它的行为，对象看起来好像修改了它的类。

## 设计模式的六大原则

### 开闭原则

**（1）开闭原则 (Open Close Principle) ：**

开闭原则指的是对扩展开放，对修改关闭。在对程序进行扩展的时候，不能去修改原有的代码，想要达到这样的效果，我们就需要使用接口或者抽象类

### 依赖倒转原则

**（2）依赖倒转原则 (Dependence Inversion Principle)：**

依赖倒置原则是开闭原则的基础，指的是针对接口编程，依赖于抽象而不依赖于具体

### 里氏替换原则

**（3）里氏替换原则 (Liskov Substitution Principle) ：**

里氏替换原则是继承与复用的基石，只有当子类可以替换掉基类，且系统的功能不受影响时，基类才能被复用，而子类也能够在基础类上增加新的行为。所以里氏替换原则指的是任何基类可以出现的地方，子类一定可以出现。

里氏替换原则是对 “开闭原则” 的补充，实现 “开闭原则” 的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。

### 接口隔离原则

**（4）接口隔离原则 (Interface Segregation Principle)：**

使用多个隔离的接口，比使用单个接口要好，降低接口之间的耦合度与依赖，方便升级和维护方便

### 迪米特原则

**（5）迪米特原则 (Demeter Principle)：**

迪米特原则，也叫最少知道原则，指的是一个类应当尽量减少与其他实体进行相互作用，使得系统功能模块相对独立，降低耦合关系。该原则的初衷是降低类的耦合，虽然可以避免与非直接的类通信，但是要通信，就必然会通过一个“中介”来发生关系，过分的使用迪米特原则，会产生大量的中介和传递类，导致系统复杂度变大，所以采用迪米特法则时要反复权衡，既要做到结构清晰，又要高内聚低耦合。

### 合成复用原则

**（6）合成复用原则 (Composite Reuse Principle)：**

尽量使用组合/聚合的方式，而不是使用继承。
